{"meta":{"title":"Blogs","subtitle":null,"description":null,"author":"Machiro-Shina","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"python函数装饰器","slug":"python函数装饰器","date":"2018-08-16T11:10:43.000Z","updated":"2018-08-18T05:44:51.782Z","comments":true,"path":"2018/08/16/python函数装饰器/","link":"","permalink":"http://yoursite.com/2018/08/16/python函数装饰器/","excerpt":"","text":"函数装饰器是可调用的对象，其参数是另一个函数(也就是被装饰的函数)。装饰器可能会处理被装饰的函数，然后将其返回；也可能会将其替换为另一个函数或可调用对象之后再返回。 函数装饰器的特性函数装饰器主要有两大特性:一: 能把被装饰的函数替换为另一个函数二: 装饰器在加载模块时会立刻执行，通常是在导入时就会运行 定义和使用定义一个装饰器和定义一个函数类似，只不过接受一个函数作为参数。使用装饰器只需要在需要装饰的函数上一行声明@decorator即可，decorator是装饰器的名字，这里不需要加括号(也存在例外，比如functools模块下的lru_cache装饰器)，使用装饰器decorator装饰函数func相当于func = decorator(func) 代码1234567891011121314151617181920212223242526registry = []def register(func): print('running register(%s)' % func.__name__) registry.append(func.__name__) return func@registerdef f1(): print('running f1()')@registerdef f2(): print('running f2()')def f3(): print('running f3()')def main(): print('running main()') print('registry: ', registry) f1() f2() f3() if __name__ == '__main__': main() 执行结果running register(f1)running register(f2)running main()registry: [‘f1’, ‘f2’]running f1()running f2()running f3() 分析执行情况由于函数装饰器是在导入模块时立刻执行，而函数f1和f2是被装饰器装饰的，f3没有被装饰器装饰，所以先调用两次register函数，然后才调用main函数。 functools模块下的lru_cache装饰器这个装饰器的主要作用是通过利用缓存来节约内存，从而提高运行速度。比如在通过递归计算较大的斐波那契数列时使用该装饰器可以极大提高运行速度。 代码12345678import functools@functools.lru_cache()def fibonacci(n): if n &lt;= 1: return n return fibonacci(n-2) + fibonacci(n-1)print(fibonacci(70)) 执行结果190392490709135 加括号的原因之所以为这个装饰器加括号，是因为可以通过使用两个可选的参数来配置该装饰器，它的签名是functools.lru_cache(maxsize=128, typed=False)。maxsize参数指定存储多少个调用的结果。缓存满了之后，旧的结果会被扔掉，让出空间。为了使性能最佳，maxsize参数应该设置为2的倍数。typed参数如果设定为True，那么就把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数(如1和1.0)区分开。 叠放装饰器如果用两个或多个装饰器共同装饰一个函数，那么装饰器的调用顺序是从下往上。使用d1，d2两个装饰器按顺序装饰函数func相当于func = d1(d2(func)) 代码123456789101112131415def decorator1(func): print('decorator1 is running') return funcdef decorator2(func): print('decorator2 is running') return func@decorator1@decorator2def main(): print('main() is running')if __name__ == '__main__': main() 执行结果decorator2 is runningdecorator1 is runningmain() is running 参数化装饰器参数化装饰器就是给装饰器函数添加一个外层函数，也就是装饰器工厂函数。调用它会返回真正的装饰器，也就是应用到目标函数上的装饰器。 代码123456789101112131415161718192021222324252627registry = set()def register(active=False): def decorate(func): print('running: ', func.__name__) if active: registry.add(func.__name__) else: registry.discard(func.__name__) return func return decorate@register(active=False)def f1(): print('f1() is running')@register(active=True)def f2(): print('f2() is running')def main(): print('main() is running') print(registry) f1() f2()if __name__ == '__main__': main() 执行结果running: f1running: f2main() is running{‘f2’}f1() is runningf2() is running","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]}